import type { LoginCredentials, AuthResponse, ServiceOrder, TimelineEvent, Report, User } from "./types"

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000/api"
// Permite desabilitar mocks em desenvolvimento setando NEXT_PUBLIC_USE_MOCKS=false
const USE_MOCKS = (process.env.NEXT_PUBLIC_USE_MOCKS ?? "true").toLowerCase() === "true"
// Permite forçar uso da API real para relatórios, mesmo com mocks habilitados
const REPORTS_USE_REAL = (process.env.NEXT_PUBLIC_REPORTS_USE_REAL ?? "true").toLowerCase() === "true"

// Mock data for development
const MOCK_USER = {
  id: "1",
  email: "admin@example.com",
  name: "Admin User",
  role: "admin" as const,
}

const MOCK_ORDERS: ServiceOrder[] = [
  {
    id: "1",
    title: "Instalação de Sistema de Ar Condicionado",
    description: "Instalação completa de sistema split em escritório comercial",
    status: "in_progress",
    priority: "high",
    clientName: "Empresa ABC Ltda",
    clientEmail: "contato@empresaabc.com",
    assignedTo: "João Silva",
    createdAt: "2025-01-15T10:00:00Z",
    updatedAt: "2025-01-16T14:30:00Z",
  },
  {
    id: "2",
    title: "Manutenção Preventiva - Sistema Elétrico",
    description: "Verificação e manutenção do sistema elétrico predial",
    status: "pending",
    priority: "medium",
    clientName: "Condomínio Residencial XYZ",
    clientEmail: "sindico@condominioxyz.com",
    createdAt: "2025-01-16T09:00:00Z",
    updatedAt: "2025-01-16T09:00:00Z",
  },
  {
    id: "3",
    title: "Reparo de Vazamento Hidráulico",
    description: "Correção de vazamento em tubulação principal",
    status: "completed",
    priority: "urgent",
    clientName: "Maria Santos",
    clientEmail: "maria.santos@email.com",
    assignedTo: "Pedro Costa",
    createdAt: "2025-01-14T08:00:00Z",
    updatedAt: "2025-01-15T16:00:00Z",
    completedAt: "2025-01-15T16:00:00Z",
  },
]

class ApiClient {
  private token: string | null = null

  constructor() {
    if (typeof window !== "undefined") {
      this.token = localStorage.getItem("auth_token")
    }
  }

  setToken(token: string) {
    this.token = token
    if (typeof window !== "undefined") {
      localStorage.setItem("auth_token", token)
    }
  }

  clearToken() {
    this.token = null
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth_token")
    }
  }

  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const headers: HeadersInit = {
      "Content-Type": "application/json",
      ...options.headers,
    }

    if (this.token) {
      headers["Authorization"] = `Bearer ${this.token}`
    }

    // Mock API responses quando habilitado via flag
    // Exceto para /reports se REPORTS_USE_REAL=true
    if (USE_MOCKS && !(REPORTS_USE_REAL && endpoint === "/reports")) {
      return this.mockRequest<T>(endpoint, options)
    }

    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      ...options,
      headers,
    })

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`)
    }

    return response.json()
  }

  private async mockRequest<T>(endpoint: string, options: RequestInit): Promise<T> {
    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 500))

    if (endpoint === "/auth/login" && options.method === "POST") {
      const body = JSON.parse(options.body as string) as LoginCredentials
      if (body.email === "admin@example.com" && body.password === "admin123") {
        return {
          user: MOCK_USER,
          token: "mock-jwt-token-" + Date.now(),
        } as T
      }
      throw new Error("Invalid credentials")
    }

    if (endpoint === "/auth/me") {
      return { user: MOCK_USER } as T
    }

    if (endpoint.startsWith("/orders")) {
      if (options.method === "GET") {
        if (endpoint.includes("/orders/") && !endpoint.includes("?")) {
          const orderId = endpoint.split("/")[2]
          const order = MOCK_ORDERS.find((o) => o.id === orderId)
          if (!order) throw new Error("Order not found")
          return order as T
        }
        return { orders: MOCK_ORDERS, total: MOCK_ORDERS.length } as T
      }
    }

    if (endpoint.startsWith("/timeline/")) {
      const orderId = endpoint.split("/")[2]
      const mockTimeline: TimelineEvent[] = [
        {
          id: "1",
          orderId,
          type: "created",
          description: "Ordem de serviço criada",
          userId: "1",
          userName: "Sistema",
          timestamp: "2025-01-15T10:00:00Z",
        },
        {
          id: "2",
          orderId,
          type: "assigned",
          description: "Atribuído para João Silva",
          userId: "1",
          userName: "Admin User",
          timestamp: "2025-01-15T10:30:00Z",
        },
        {
          id: "3",
          orderId,
          type: "status_change",
          description: "Status alterado para Em Progresso",
          userId: "2",
          userName: "João Silva",
          timestamp: "2025-01-16T08:00:00Z",
        },
        {
          id: "4",
          orderId,
          type: "comment",
          description: "Técnico chegou ao local e iniciou avaliação",
          userId: "2",
          userName: "João Silva",
          timestamp: "2025-01-16T09:15:00Z",
        },
      ]
      return mockTimeline as T
    }

    if (endpoint === "/reports") {
      const mockReport: Report = {
        totalOrders: 45,
        completedOrders: 32,
        pendingOrders: 8,
        inProgressOrders: 5,
        averageCompletionTime: 2.5,
        ordersByStatus: [
          { status: "completed", count: 32 },
          { status: "in_progress", count: 5 },
          { status: "pending", count: 8 },
        ],
        ordersByPriority: [
          { priority: "urgent", count: 5 },
          { priority: "high", count: 12 },
          { priority: "medium", count: 18 },
          { priority: "low", count: 10 },
        ],
      }
      return mockReport as T
    }

    throw new Error("Endpoint not mocked")
  }

  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    return this.request<AuthResponse>("/auth/login", {
      method: "POST",
      body: JSON.stringify(credentials),
    })
  }

  async getCurrentUser(): Promise<{ user: User }> {
    return this.request<{ user: User }>("/auth/me")
  }

  async getOrders(params?: { status?: string; page?: number; limit?: number }): Promise<{
    orders: ServiceOrder[]
    total: number
  }> {
    const queryParams = new URLSearchParams()
    if (params?.status) queryParams.append("status", params.status)
    if (params?.page) queryParams.append("page", params.page.toString())
    if (params?.limit) queryParams.append("limit", params.limit.toString())

    const query = queryParams.toString()
    return this.request<{ orders: ServiceOrder[]; total: number }>(`/orders${query ? `?${query}` : ""}`)
  }

  async getOrderById(id: string): Promise<ServiceOrder> {
    return this.request<ServiceOrder>(`/orders/${id}`)
  }

  async getOrderTimeline(orderId: string): Promise<TimelineEvent[]> {
    return this.request<TimelineEvent[]>(`/timeline/${orderId}`)
  }

  async getReports(): Promise<Report> {
    return this.request<Report>("/reports")
  }
}

export const apiClient = new ApiClient()

